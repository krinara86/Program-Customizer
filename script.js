const defaultPrayerText = `In the Samaya Tradition we are taught to pray in our own words. So instead of repeating prayers in dead languages out of scriptures or translations of the same, you can have a conversation with the Divine in your mother tongue or your primary language. This Samaya prayer is a form of internal dialogue. You can use internal dialogue to converse with the Divine in your own language, in your own words. Since the Divinity within is subtler than the subtlest, it is hard for most of us to have a conversation with it. Therefore, you can relate to the Divinity in yourself as your mother, father, master, friend or lover. Some prefer to relate to the Divinity within as a teacher or guiding light.
While there may be many different kinds of prayers asking for fulfillment of worldly desires, the following prayers described here are those recommended by the Samaya tradition.
A prayer of petition: This is the most important prayer for those who start systematic meditation. You are praying for sankalpa shakti, that is, for the determination and will power to continue on this path. Pray four times daily before practice asking for internal strength and guidance on this inner journey. Ask the Divinity within you for courage to continue on the path of Truth. Remember, when you practice with full commitment you are always protected. Even if you do not do any systematic meditation practice, you can still pray four times a day.
A prayer of thanksgiving: The second kind of prayer is an expression of gratitude for all the good and beautiful gifts you have, including your body. To have a human body and live out desires on this plane of existence is a privilege. We all tend to get gloomy in the face of troubles and problems, but instead of becoming negative you learn to focus on the good and beautiful in your life by counting your blessings. Express your gratitude for the good and beautiful in your life before or after your systematic meditation practice four times daily. If you do not practice, you can still express gratitude to the Divinity within at least once a day.
How to pray
When should I pray? Most of us only pray when we are anxious and in trouble. However, best practice is to pray daily, even four times a day, as many religions prescribe. The timings of prayer should not conflict with your general routine. Meal times are anchors in everyone’s day, so you can pray in the morning before breakfast, at midday before lunch, at dusk before an early evening meal and a fourth time before bedtime. Those who practice systematic meditation four times a day, can add a short prayer before and after the meditation practice.
To whom shall I pray? If you are unable to develop a relationship with the Divinity within you, then you can pray to a deity that you are drawn to, keeping in mind that deities are auspicious symbols. You can also pray to saints and sages. In the Samaya tradition, internal prayer is preferred. The Divinity within is God without attributes (nirguna brahman). Sages, saints and deities are God with attributes (saguna brahman). The choice between the two depends on the nature of your mind and what you feel drawn to. 
Where shall I pray? While it is common to pray in a house of worship or in front of an altar at home, you can pray anywhere. According to the Samaya tradition there is no inauspicious place and if you believe a place to be inauspicious, prayer will surely purify it and make it auspicious. It is recommended to have a fixed area or space at home for prayer. An altar is not necessary.
What is the best posture for prayer? You can pray in any posture you like, standing, seated or even lying down. While the supine position is only recommended if you are unwell or have a physical disability, the standing and seated positions are a matter of preference. If you chose to have a seated position you can sit on a chair with your back straight or on a meditation mat.
`;


const LIABILITY_STATEMENT = `This document has not been created by a medical doctor or healing practitioner. Therefore, please perform all practices mentioned in this document at your own discretion. 

If you have or have had an injury or acute illness, or if you have doubts about whether yoga practices are appropriate for you, you are responsible for contacting your physician as needed to inquire about your fitness level.

The instructions and advice given in yoga sessions are no substitute for professional medical or psychological care. The instructions and advice given in the following document is not a substitute for professional medical or psychological care. 

If you are pregnant or experiencing menopausal transition, you are responsible for taking special care of yourself and consulting your doctor as needed.

If you are menstruating, do not exceed your comfort levels.

In order for yoga practice to be beneficial for you and your all-round health, please let us know if you are suffering from physical illness or have any other health restrictions that would prevent you from participating in yoga practice or in individual yoga exercises. 

In case of severe health issues or chronic illness(es) please check with your doctor whether you are allowed to participate in the yoga related activities. Participation is at your own risk.

The use of any suggested devices or equipment such as the indoor bike, resistance bands, chairs, pillows or any other props is at the yoga participant's own risk.

Any cardio training suggested is to be practiced at your own discretion.`;



const defaultDietText = `Do not eat raw foods like salad early in the morning or in the evening. 
Keep a gap of 2-3 hours between meals. Always eat warm meals. As far as possible eat organic foods.

Always eat a warm porridge with dried fruit and nuts for breakfast. You can also grate sweet apples into the porridge and cook it. You can make porridge out of oats, amaranth, quinoa and bulgur. You can add bananas on top. Berries are excellent, if you cook them along with the porridge.

Avoid mushrooms, paprika, garlic, onions, heavy lentils, eggs, fried foods, cold food, frozen foods, industrialized food like ready made breads, alcohol, white refined sugar, refined breads, refined oils as these are tamasic or rajasic.

Drink 2-3 liters of plain water everyday without gas. Do not drink water 30 minutes before and after meals. If you have digestive problems such as gases, acidity or constipation always drink warm water.

Drink mild herbal teas like mixed herbs, fennel/anis/cumin, fasting teas, alkaline teas, chamomile tea, tulsi tea. Avoid teas with added sugar, colors and flavoring agents.

Avoid coffee and black tea . Alternatives: moringa leaves, tulsi, rooi busch,

Lunch is the most important meal of the day between 11 am and 2 pm. During lunch if you wish, you can have a little raw salad since the digestive fire is the strongest at this time of the day. If you want to have something sweet, this is the time you can have a small dessert, candy, biscuit or mithai. Dairy products such as yoghurt, lassi, cheese are best consumed at this time.

Dinner is a good time for simple one pot meals like khichidi. You can always have rice, vegetables and lentils if you prefer. Do not have bread, salad, dairy products or any cold food or drinks in the evening. Best for you is light food, steamed or lightly sautéed in little oil or ghee.

A variety of grains is preferred. Make sure you do not only have wheat products. Also enjoy oats, parboiled rice, spelt, amaranth, bulgur, quinoa, couscous, barley, maize and millet. 
There is a huge variety of vegetables. Eat at least 25 different plants in a week: Pumpkin, beetroot, carrots, sweet potatoes, potatoes, zucchini, spinach, tomatoes, avocado, Many Indian vegetables are highly nutrient dense and therefore extremely healthy like drumsticks (moringa).
Herbs: fenugreek leaves, fresh coriander and other herbs
Lentils: red lentils, moong lentils, moong beans 
Fruit: sweet fruit like bananas, coconut, apples, figs, dates, grapes, mangoes, papaya, berries (cooked)
Seeds and Nuts: sunflower, pumpkin, almonds

Milk products: ghee, paneer, cow's milk (warm with cardamom) Butter, sheep or goat cheese like feta. Yoghurt only in afternoon. Avoid yoghurt in the morning or evening.
Sweetners: Jaggery, (light colored) honey, maple syrup, agave 
Oils and fat: Ghee, olive oil, coconut oil, butter
Spices: coriander, cumin, cardamom, turmeric, fennel, oregano, rosemary, anise, thyme, ginger`;

const defaultRoutineText = `A structured routine is very important for you:
Go to bed by 10:00 pm
Wake up by 6 am

Morning Routine on waking up:
- Wash face, splash cold water on eyes
- Brush teeth first
- Then do Oil pulling with coconut oil for 5-10 minutes, spit out in garbage (not in washbasin)
- Tongue cleaning with metal tongue cleaner
- Drink at least 2 glasses of warm water 
- Wash yourself. Daily shower is not necessary. 
- Do yoga sadhana
- Go for at least 3 kms brisk walk
- Drink warm lemon with salt and honey before breakfast`;

async function loadDefaultTexts() {
  try {
    // Set the default texts to the textareas if they're empty
    const dietTextArea = document.getElementById('dietAndAdditionalNotes');
    const routineTextArea = document.getElementById('routineText');

    if (!dietTextArea.value || dietTextArea.value.trim() === '') {
      dietTextArea.value = defaultDietText;
    }
    if (!routineTextArea.value || routineTextArea.value.trim() === '') {
      routineTextArea.value = defaultRoutineText;
    }

    console.log('Default texts loaded successfully');
  } catch (error) {
    console.error('Error setting default texts:', error);
  }
}


// Initialize Firebase
// TODO: replace with your own Firebase config
var firebaseConfig = {
  apiKey: "AIzaSyD2Qv-8dC9atWBU_IFWXmxsGSp5T-_FOtM",
  authDomain: "sadhakacustomizer.firebaseapp.com",
  projectId: "sadhakacustomizer",
  storageBucket: "sadhakacustomizer.appspot.com",
  messagingSenderId: "401905258509",
  appId: "1:401905258509:web:cd9661bbe700b04fa00544"
};
firebase.initializeApp(firebaseConfig);
var db = firebase.firestore();

var asanas = [];
var sadhakaNames = [];
var sadhakaNameInput = document.getElementById('sadhakaName');
var sadhakaNameList = document.getElementById('sadhakaNameList');
var sadhakaNameSuggestions = document.getElementById('sadhakaNameSuggestions');

var categories = [
  { id: 'prayerSection', elementId: 'prayerText', title: 'Prayer', type: 'text', order: 1 },
  { id: 'advisorySection', elementId: 'advisoryText', title: 'Advisory', type: 'text', order: 2 },
  { id: 'jointsAndGlandsSection', elementId: 'jointsAndGlandsDiv', title: 'Joints and Glands', type: 'asanas', category: 'Joints and Glands', notesId: 'jointsAndGlandsNotes', order: 3 },
  { id: 'cardioSection', elementId: 'cardioDiv', title: 'Cardio Day Asanas', type: 'asanas', category: 'Physical Asana', notesId: 'cardioNotes', order: 4 },
  { id: 'nonCardioSection', elementId: 'nonCardioDiv', title: 'Non-Cardio Day Asanas', type: 'asanas', category: 'Physical Asana', notesId: 'nonCardioNotes', order: 5 },
  { id: 'relaxationSection', elementId: 'relaxationDiv', title: 'Relaxation Asanas', type: 'asanas', category: 'Relaxation', order: 6 },
  { id: 'meditativeSection', elementId: 'meditativeDiv', title: 'Meditative Asanas', type: 'asanas', category: 'Meditative Asana', order: 7 },
  { id: 'breathingSection', elementId: 'breathingDiv', title: 'Breathing exercises', type: 'asanas', category: 'Breathing', order: 8 },
  { id: 'pranayamaSection', elementId: 'pranayamaDiv', title: 'Pranayama', type: 'asanas', category: 'Pranayana', order: 9 },
  { id: 'meditationSection', elementId: 'meditationDiv', title: 'Meditation', type: 'asanas', category: 'Meditation', order: 10 },
  { id: 'routineSection', elementId: 'routineText', title: 'Routine', type: 'text', order: 11 },
  { id: 'dietAndAdditionalNotesSection', elementId: 'dietAndAdditionalNotes', title: 'Dietary recommendations', type: 'text', order: 12 }
];

async function addAsanaContent(pdf, asanaDiv, pdfConfig, asanasMap, colors) {
  const asanaNameSelect = asanaDiv.querySelector('.asanaNameSelect');
  if (!asanaNameSelect || !asanaNameSelect.value) {
    return pdfConfig.y;
  }

  let y = pdfConfig.y; // Current Y position passed from calling function
  const asanaName = asanaNameSelect.value;
  const repetitionsInput = asanaDiv.querySelector('#repetitionsInput');
  const specialNotesTextarea = asanaDiv.querySelector('#specialNotesTextarea');
  const contentWidth = pdfConfig.pageWidth - (2 * pdfConfig.margin);

  try {
    const asanaDoc = await db.collection('asanas').where("name", "==", asanaName).get();
    if (asanaDoc.empty) return y;

    const asanaData = asanaDoc.docs[0].data(); // Correctly fetch asanaData here

    // Values
    const displayName = normalizeText(asanaData.displayName || asanaData.name);
    const repetitions = repetitionsInput ? normalizeText(repetitionsInput.value) : '';
    const specialNotes = specialNotesTextarea ? normalizeText(specialNotesTextarea.value) : '';
    const description = normalizeText(asanasMap.get(asanaName));

    // Calculate required space for the *entire asana block* including image, title, notes, description
    let requiredHeight = 0;
    requiredHeight += pdf.splitTextToSize(displayName, contentWidth).length * 14; // Asana Display Name height
    requiredHeight += 10; // Space below asana name

    if (asanaData.imageUrl) {
      requiredHeight += 180; // image height (fixed size)
      requiredHeight += 20; // Space after image
    }

    if (repetitions) {
      requiredHeight += 20; // Repetitions line height
    }
    if (specialNotes) {
      requiredHeight += pdf.splitTextToSize(specialNotes, contentWidth).length * 14; // Notes height (approx)
      if (repetitions) requiredHeight += 5; // Small extra space if both exist
    }
    if (description) {
      requiredHeight += pdf.splitTextToSize(description, contentWidth).length * 14; // Description height (approx)
      if (repetitions || specialNotes) requiredHeight += 5; // Small extra space
    }
    requiredHeight += 25; // Additional spacing after this asana block

    // Check for page break for the entire asana block. If it doesn't fit, add a new page.
    if (y + requiredHeight > pdfConfig.pageHeight - pdfConfig.margin) {
      pdf.addPage();
      y = pdfConfig.margin; // Reset y to the top margin on the new page
    }

    // --- Draw Asana Content ---

    // Add Image
    if (asanaData.imageUrl) { // Use asanaData.imageUrl here
      try {
        const base64data = await urlToDataUri(asanaData.imageUrl); // Corrected: use asanaData.imageUrl
        const imageWidth = 180;
        const imageHeight = 180;
        const imageX = (pdfConfig.pageWidth - imageWidth) / 2;

        pdf.setDrawColor(colors.lightGrey);
        pdf.setLineWidth(1);
        pdf.setFillColor(240, 240, 240); // Light grey fill for shadow
        pdf.rect(imageX + 3, y + 3, imageWidth, imageHeight, 'F'); // Shadow
        pdf.addImage(base64data, 'PNG', imageX, y, imageWidth, imageHeight);
        pdf.rect(imageX, y, imageWidth, imageHeight, 'S'); // Border

        y += imageHeight + 20; // Update y after image
      } catch (e) {
        console.error("Error adding image:", e);
      }
    }

    // Asana Display Name
    pdf.setFontSize(14);
    pdf.setFont("helvetica", "bold");
    pdf.setTextColor(colors.primaryText); // Ensure asana display name is primary text color
    y = addText(pdf, displayName, pdfConfig.margin, y, {
      ...pdfConfig, // Pass full config including margins
      size: 14,
      style: 'bold',
      maxWidth: contentWidth,
      currentY: y // Pass current y to addText for internal page breaks
    });
    y += 10; // Space below asana name

    // Repetitions and Special Notes
    pdf.setFontSize(12);
    pdf.setTextColor(colors.primaryText); // Ensure repetitions and special notes are primary text color

    if (repetitions) {
      pdf.setFont("helvetica", "bold");
      pdf.text("Repetitions:", pdfConfig.margin, y);
      pdf.setFont("helvetica", "normal");
      pdf.text(repetitions, pdfConfig.margin + 70, y);
      y += 20;
    }

    if (specialNotes) {
      pdf.setFont("helvetica", "bold");
      pdf.text("Special Notes:", pdfConfig.margin, y);
      pdf.setFont("helvetica", "italic");
      y = addText(pdf, specialNotes, pdfConfig.margin + 85, y, {
        ...pdfConfig,
        size: 12,
        style: 'italic',
        maxWidth: contentWidth - 85, // Adjust max width for notes
        currentY: y // Pass current y for internal page breaks
      });
      y += 10;
    }

    // Description
    if (description) {
      pdf.setFont("helvetica", "normal");
      pdf.setTextColor(colors.primaryText); // Ensure description is primary text color
      y = addText(pdf, description, pdfConfig.margin, y, {
        ...pdfConfig,
        size: 12,
        style: 'normal',
        maxWidth: contentWidth,
        currentY: y // Pass current y for internal page breaks
      });
    }

    return y + 25; // Return final y with spacing after the entire asana block
  } catch (error) {
    console.error("Error in addAsanaContent:", error);
    return y;
  }
}

function normalizeText(text) {
  if (!text || typeof text !== 'string') {
    return '';
  }

  // First, standardize paragraph breaks to be exactly two newlines
  let processedText = text.trim().replace(/\r\n/g, '\n').replace(/(\n\s*){2,}/g, '\n\n');

  // Next, split the whole text into paragraphs
  const paragraphs = processedText.split('\n\n');

  // Clean up each paragraph by removing single newlines within them
  const cleanedParagraphs = paragraphs.map(paragraph => {
    // Replace single newlines with a space and collapse multiple spaces
    return paragraph.replace(/\n/g, ' ').replace(/\s+/g, ' ');
  });

  // Join the cleaned paragraphs back together with a proper paragraph break
  return cleanedParagraphs.join('\n');
}

function addText(pdf, text, x, y, options) {
  const { maxWidth, font, size, style } = options;
  const lineHeight = size * 1.2; // A good line height for readability
  const pageHeight = pdf.internal.pageSize.height;
  const margin = 40;

  pdf.setFont(font, style);
  pdf.setFontSize(size);

  const lines = pdf.splitTextToSize(text, maxWidth);
  const blockHeight = lines.length * lineHeight;

  // Check if the block of text fits on the current page
  if (y + blockHeight > pageHeight - margin) {
    pdf.addPage();
    y = margin; // Reset y to the top margin on the new page
  }

  pdf.text(lines, x, y);

  // Return the new y position after this block of text
  return y + blockHeight;
}


function urlToDataUri(url) {
  return fetch(url)
    .then(response => response.blob())
    .then(blob => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    });
}

async function saveSadhakaReportAsPdf() {
  const asanasMap = await loadAsanasForPdf();
  const pdf = new jsPDF('p', 'pt', 'a4');
  const sadhakaName = document.getElementById('sadhakaName').value;

  // --- Design & Color Palette ---
  const colors = {
    primaryText: '#333333', // Dark Grey - This is the default for most text
    headerBlue: '#005A9C', // Professional Blue - For section titles and main PDF title
    lightGrey: '#CCCCCC', // Light Grey for borders/lines
    subtleText: '#777777' // Lighter grey for subtitles like date/page numbers
  };

  const pdfConfig = {
    pageWidth: pdf.internal.pageSize.width,
    pageHeight: pdf.internal.pageSize.height,
    margin: 50, // Increased margin for a cleaner look
  };
  const contentWidth = pdfConfig.pageWidth - (2 * pdfConfig.margin);

  // --- Title Page ---
  pdf.setFont("helvetica", "normal");
  const logoUrl = 'https://images.squarespace-cdn.com/content/v1/62f11860fb33eb592879527c/73af335a-bc0d-4450-a4c0-32ad86ceb033/neue+weisse+blumen+logo.png';
  try {
    const logoWidth = 80;
    const logoHeight = 80;
    const logoDataUri = await urlToDataUri(logoUrl);
    pdf.addImage(logoDataUri, 'PNG', (pdfConfig.pageWidth - logoWidth) / 2, 150, logoWidth, logoHeight);
  } catch (e) {
    console.error("Could not add logo to PDF:", e);
  }

  const centerX = pdfConfig.pageWidth / 2;
  pdf.setFontSize(26);
  pdf.setFont("helvetica", "bold");
  pdf.setTextColor(colors.headerBlue); // Set color for main title
  pdf.text("Sadhana Plan", centerX, 320, {
    align: 'center'
  });

  pdf.setFontSize(20);
  pdf.setFont("helvetica", "normal");
  pdf.setTextColor(colors.primaryText); // Reset to primary text color
  pdf.text(`for ${sadhakaName}`, centerX, 360, {
    align: 'center'
  });

  const date = new Date().toLocaleDateString('en-GB', {
    day: 'numeric',
    month: 'long',
    year: 'numeric'
  });
  pdf.setFontSize(12);
  pdf.setFont("helvetica", "italic");
  pdf.setTextColor(colors.subtleText); // Set color for date
  pdf.text(`Created on ${date}`, centerX, 400, {
    align: 'center'
  });


  // --- Main Content ---
  pdf.addPage();
  let y = pdfConfig.margin;

  const sectionElementsInOrder = Array.from(document.querySelectorAll('.section'));
  const sortedCategories = sectionElementsInOrder.map(sectionEl => {
    return categories.find(cat => cat.id === sectionEl.id);
  }).filter(Boolean);


  for (const category of sortedCategories) {
    let categoryHasContent = false;
    let notes = '';

    const notesElementId = {
      'jointsAndGlandsDiv': 'jointsAndGlandsNotes',
      'cardioDiv': 'cardioNotes',
      'nonCardioDiv': 'nonCardioNotes'
    }[category.elementId];

    if (notesElementId) {
      notes = normalizeText(document.getElementById(notesElementId).value);
      if (notes) categoryHasContent = true;
    }

    if (category.type === 'text') {
      const content = normalizeText(document.getElementById(category.elementId).value);
      if (content && content.trim() !== '' &&
        content !== normalizeText(defaultPrayerText) &&
        content !== normalizeText(defaultDietText) &&
        content !== normalizeText(defaultRoutineText)) {
        categoryHasContent = true;
      }
    } else if (category.type === 'asanas') {
      const containerDiv = document.getElementById(category.elementId);
      if (containerDiv && containerDiv.children.length > 0) {
        categoryHasContent = true;
      }
    }

    if (!categoryHasContent) continue;

    let sectionIntroHeightEstimate = 18;
    sectionIntroHeightEstimate += 10;
    sectionIntroHeightEstimate += 1;
    sectionIntroHeightEstimate += 20;

    if (notes) {
      const splitNotes = pdf.splitTextToSize(`Notes: ${notes}`, contentWidth);
      sectionIntroHeightEstimate += splitNotes.length * 14;
      sectionIntroHeightEstimate += 10;
    }

    if (y + sectionIntroHeightEstimate > pdfConfig.pageHeight - pdfConfig.margin) {
      pdf.addPage();
      y = pdfConfig.margin;
    }

    // Add section header
    pdf.setFontSize(18);
    pdf.setFont("helvetica", "bold");
    pdf.setTextColor(colors.headerBlue); // Set color for section titles
    pdf.text(category.title, pdfConfig.margin, y);
    y += 10;

    // Add a line under the header
    pdf.setDrawColor(colors.lightGrey);
    pdf.setLineWidth(1);
    pdf.line(pdfConfig.margin, y, pdfConfig.pageWidth - pdfConfig.margin, y);
    y += 20;

    // Handle and display section notes
    if (notes) {
      pdf.setFont("helvetica", "italic");
      pdf.setTextColor(colors.primaryText); // Ensure notes are primary text color
      y = addText(pdf, `Notes: ${notes}`, pdfConfig.margin, y, {
        ...pdfConfig,
        size: 12,
        font: 'helvetica',
        style: 'italic',
        maxWidth: contentWidth,
        currentY: y
      });
      y += 10;
    }

    // Display the main content for the category
    if (category.type === 'text') {
      const content = normalizeText(document.getElementById(category.elementId).value);
      if (content) {
        pdf.setTextColor(colors.primaryText); // Ensure text content is primary text color
        y = addText(pdf, content, pdfConfig.margin, y, {
          ...pdfConfig,
          size: 12,
          font: 'helvetica',
          style: 'normal',
          maxWidth: contentWidth,
          currentY: y
        });
      }
    } else if (category.type === 'asanas') {
      const containerDiv = document.getElementById(category.elementId);
      if (containerDiv && containerDiv.children.length > 0) {
        for (let i = 0; i < containerDiv.children.length; i++) {
          y = await addAsanaContent(pdf, containerDiv.children[i], {
            ...pdfConfig,
            y: y
          }, asanasMap, colors);
        }
      }
    }
    y += 20;
  }

  // --- Add Borders and Page Numbers to All Pages ---
  const totalPages = pdf.internal.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    pdf.setPage(i);
    pdf.setDrawColor(colors.lightGrey);
    pdf.setLineWidth(0.5);
    pdf.rect(20, 20, pdfConfig.pageWidth - 40, pdfConfig.pageHeight - 40);

    // Add Page Number (skip on title page)
    if (i > 1) {
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      pdf.setTextColor(colors.subtleText); // Set color for page numbers
      pdf.text(`Page ${i - 1}`, pdfConfig.pageWidth / 2, pdfConfig.pageHeight - 30, {
        align: 'center'
      });
    }
  }

  pdf.save(`${sadhakaName}_sadhana_plan.pdf`);
}

async function addSection(pdf, category, pdfConfig, asanasMap) {
  // Add section header
  pdf.setFontSize(16);
  pdf.setFont("Roboto", "bold");
  pdf.text(category.title, pdfConfig.margin, pdfConfig.y);
  pdfConfig.y += 20;

  // Add category notes for specific sections
  const categoryNotesMap = {
    'jointsAndGlandsDiv': 'jointsAndGlandsNotes',
    'cardioDiv': 'cardioNotes',
    'nonCardioDiv': 'nonCardioNotes'
  };

  const notesElementId = categoryNotesMap[category.id];
  if (notesElementId) {
    const notes = document.getElementById(notesElementId).value;
    if (notes && notes.trim()) {
      pdf.setFontSize(12);
      pdf.setFont("Roboto", "italic");
      const splitNotes = pdf.splitTextToSize(`Category Notes: ${notes}`, pdfConfig.pageWidth - (2 * pdfConfig.margin));
      pdf.text(splitNotes, pdfConfig.margin, pdfConfig.y);
      pdfConfig.y += splitNotes.length * 15 + 10;
    }
  }

  if (category.type === 'text') {
    const content = document.getElementById(category.id).value;
    if (content && content.trim()) {
      pdf.setFontSize(12);
      pdf.setFont("Roboto", "normal");
      const splitContent = pdf.splitTextToSize(content, pdfConfig.pageWidth - (2 * pdfConfig.margin));
      pdf.text(splitContent, pdfConfig.margin, pdfConfig.y);
      pdfConfig.y += splitContent.length * 15 + 20;
    }
  } else if (category.type === 'asanas') {
    const containerDiv = document.getElementById(category.id);
    if (containerDiv && containerDiv.children.length > 0) {
      for (let i = 0; i < containerDiv.children.length; i++) {
        pdfConfig.y = await addAsanaContent(pdf, containerDiv.children[i], pdfConfig, asanasMap);

        if (i < containerDiv.children.length - 1) {
          pdf.setDrawColor(224, 224, 224);
          pdf.line(pdfConfig.margin, pdfConfig.y - 10, pdfConfig.pageWidth - pdfConfig.margin, pdfConfig.y - 10);
          pdfConfig.y += 10;
        }
      }
    }
  }

  return pdfConfig.y;
}

function urlToDataUri(url) {
  return fetch(url)
    .then(response => response.blob())
    .then(blob => {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    });
}


async function loadAsanasForPdf() {
  let returnAsanas = new Map();
  try {
    const querySnapshot = await db.collection('asanas').get();

    querySnapshot.forEach((doc) => {
      let asana = doc.data();
      // Storing only the description, as was the original design
      returnAsanas.set(asana.name, asana.description);
    });

    console.log("Fetched Asana descriptions for PDF generation.");
    return returnAsanas;

  } catch (error) {
    console.log("Error fetching Asanas:", error);
    throw error;
  }
}

function loadAsanas() {
  return new Promise((resolve, reject) => {
    db.collection('asanas').get().then((querySnapshot) => {
      var returnAsanas = [];
      querySnapshot.forEach((doc) => {
        var asana = doc.data();
        var asanaTuple = [asana.name, asana.description, asana.displayName, asana.category];
        returnAsanas.push(asanaTuple);
      });
      console.log("Fetched Asanas:", returnAsanas);
      resolve(returnAsanas);
    }).catch((error) => {
      console.error("Error fetching Asanas:", error);
      reject(error);
    });
  });
}


function loadSadhakaNames() {
  return new Promise((resolve, reject) => {
    db.collection('sadhakas').get().then((querySnapshot) => {
      var names = [];
      querySnapshot.forEach((doc) => {
        names.push(doc.id);
      });
      resolve(names);
    }).catch((error) => {
      console.log("Error fetching Sadhaka names:", error);
      reject(error);
    });
  });
}


function initialize() {
  document.querySelector('.login-container').style.display = 'block';
  document.querySelector('#overlay').style.display = 'block';
  Promise.all([loadAsanas(), loadSadhakaNames(), loadDefaultTexts()])
    .then(([fetchedAsanas, fetchedNames]) => {
      asanas = fetchedAsanas; // Assign fetched asanas to global asanas array
      sadhakaNames = fetchedNames;
      populateSadhakaNameList();
      // setupDragAndDrop() will be called by displaySadhaka when a sadhaka is loaded,
      // or if no sadhaka is loaded, we can call it here once.
      // For initial load without a selected sadhaka, ensure drag/drop is enabled.
      if (!sadhakaNameInput.value) { // If no sadhaka name pre-selected
        setupDragAndDrop();
      }
      console.log("Initialization complete. Asanas:", asanas);
    }).catch((error) => {
      console.error("Error initializing:", error);
    });
}

function populateSadhakaNameList() {
  sadhakaNameList.innerHTML = ''; // Clear previous options

  sadhakaNames.forEach((name) => {
    var option = document.createElement('option');
    option.value = name;
    sadhakaNameList.appendChild(option);
  });
}


async function saveSadhakaToDB(sadhaka) {
  if (!sadhaka.name) {
    console.error('Error: sadhaka.name is not defined or is an empty string.');
    return;
  }

  try {
    await db.collection('sadhakas').doc(sadhaka.name).set(sadhaka, { merge: true });
    console.log('Sadhaka data has been saved with ID: ', sadhaka.name);
  } catch (error) {
    console.error('Error saving sadhaka: ', error);
    throw error; // Re-throw to be caught by the calling function
  }
}

function getAsanasFromDiv(div) {
  var asanas = [];
  if (!div) return asanas;

  for (let i = 0; i < div.children.length; i++) {
    let asanaDiv = div.children[i];
    let asanaName = asanaDiv.querySelector('.asanaNameSelect')?.value || '';

    // Check if this is a section with notes
    let isSectionWithNotes = ['jointsAndGlandsDiv', 'cardioDiv', 'nonCardioDiv'].includes(div.id);

    let asana = {
      asanaName: asanaName
    };

    // Only add repetitions if not in a section with notes
    if (!isSectionWithNotes) {
      asana.repetitions = asanaDiv.querySelector('#repetitionsInput')?.value || '';
    }

    // Only add special notes for sections that allow them
    let specialNotesTextarea = asanaDiv.querySelector('#specialNotesTextarea');
    if (specialNotesTextarea) {
      asana.specialNotes = specialNotesTextarea.value || '';
    }

    if (asana.asanaName) {
      asanas.push(asana);
    }
  }
  return asanas;
}

async function deleteSadhaka() {
  const sadhakaName = document.getElementById('sadhakaName').value;

  if (!sadhakaName) {
    alert('Please select a sadhaka to delete');
    return;
  }

  if (confirm(`Are you sure you want to delete ${sadhakaName}?`)) {
    try {
      await db.collection('sadhakas').doc(sadhakaName).delete();
      alert('Sadhaka deleted successfully');

      // Update the sadhaka names list
      sadhakaNames = sadhakaNames.filter(name => name !== sadhakaName);
      populateSadhakaNameList();

      // Clear the form
      document.getElementById('sadhakaName').value = '';
      clearSadhakaDiv();
    } catch (error) {
      console.error('Error deleting sadhaka:', error);
      alert('Error deleting sadhaka');
    }
  }
}

function toggleMultiSelect() {
  const container = document.getElementById('multiSelectContainer');
  if (container.style.display === 'none') {
    container.style.display = 'block';
    populateMultiSelect();
  } else {
    container.style.display = 'none';
  }
}

function populateMultiSelect() {
  const container = document.getElementById('sadhakaCheckboxes');
  container.innerHTML = '';

  sadhakaNames.forEach(name => {
    const div = document.createElement('div');
    div.style.display = 'flex';
    div.style.alignItems = 'center';
    div.style.gap = '8px';

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = name;
    checkbox.id = `sadhaka-${name}`;

    const label = document.createElement('label');
    label.htmlFor = `sadhaka-${name}`;
    label.textContent = name;

    div.appendChild(checkbox);
    div.appendChild(label);
    container.appendChild(div);
  });
}

async function deleteSelectedSadhakas() {
  const selected = Array.from(document.querySelectorAll('#sadhakaCheckboxes input:checked'))
    .map(cb => cb.value);

  if (selected.length === 0) {
    alert('Please select at least one sadhaka to delete');
    return;
  }

  if (confirm(`Are you sure you want to delete ${selected.length} sadhaka(s)?`)) {
    try {
      const batch = db.batch();
      selected.forEach(name => {
        const ref = db.collection('sadhakas').doc(name);
        batch.delete(ref);
      });

      await batch.commit();
      alert('Selected sadhakas deleted successfully');

      // Update the sadhaka names list
      sadhakaNames = sadhakaNames.filter(name => !selected.includes(name));
      populateSadhakaNameList();

      // Clear the form and multi-select
      document.getElementById('sadhakaName').value = '';
      clearSadhakaDiv();
      toggleMultiSelect();
    } catch (error) {
      console.error('Error deleting sadhakas:', error);
      alert('Error deleting sadhakas');
    }
  }
}

function showMultiDeleteModal() {
  const modal = document.getElementById('multiDeleteModal');
  modal.style.display = 'block';
  populateSadhakaCheckboxes();
}

function closeMultiDeleteModal() {
  const modal = document.getElementById('multiDeleteModal');
  modal.style.display = 'none';
}

function populateSadhakaCheckboxes() {
  const container = document.getElementById('sadhakaCheckboxList');
  container.innerHTML = '';

  // Ensure sadhakaNames is populated
  if (sadhakaNames.length === 0) {
    // Attempt to load sadhaka names if not already loaded
    loadSadhakaNames().then(names => {
      sadhakaNames = names;
      renderSadhakaCheckboxes(container);
    }).catch(error => {
      console.error("Error loading sadhaka names for multi-delete:", error);
      container.textContent = "Error loading sadhakas.";
    });
  } else {
    renderSadhakaCheckboxes(container);
  }
}

function renderSadhakaCheckboxes(container) {
  sadhakaNames.forEach(name => {
    const div = document.createElement('div');
    div.style.display = 'flex';
    div.style.alignItems = 'center';
    div.style.padding = '4px 0';
    div.style.width = '100%';

    const checkboxWrapper = document.createElement('div');
    checkboxWrapper.style.width = '24px';
    checkboxWrapper.style.display = 'flex';
    checkboxWrapper.style.justifyContent = 'center';

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = name;
    checkbox.id = `sadhaka-${name}`;
    checkboxWrapper.appendChild(checkbox);

    const label = document.createElement('label');
    label.htmlFor = `sadhaka-${name}`;
    label.textContent = name;
    label.style.marginLeft = '8px';
    label.style.flex = '1';

    div.appendChild(checkboxWrapper);
    div.appendChild(label);
    container.appendChild(div);
  });

  // Add search functionality
  document.getElementById('sadhakaSearchInput').addEventListener('input', function (e) {
    const searchText = e.target.value.toLowerCase();
    const checkboxDivs = container.children;

    Array.from(checkboxDivs).forEach(div => {
      const label = div.querySelector('label');
      const shouldShow = label.textContent.toLowerCase().includes(searchText);
      div.style.display = shouldShow ? 'flex' : 'none';
    });
  });
}

function showChangePasswordModal() {
  const modal = document.getElementById('changePasswordModal');
  modal.style.display = 'block';
  // Clear previous inputs
  document.getElementById('currentPassword').value = '';
  document.getElementById('newPassword').value = '';
  document.getElementById('confirmPassword').value = '';
}

function closeChangePasswordModal() {
  const modal = document.getElementById('changePasswordModal');
  modal.style.display = 'none';
}

async function changePassword() {
  const modal = document.getElementById('changePasswordModal');
  const currentPassword = modal.querySelector('#currentPassword').value;
  const newPassword = modal.querySelector('#newPassword').value;
  const confirmPassword = modal.querySelector('#confirmPassword').value;

  console.log('Passwords:', { currentPassword, newPassword, confirmPassword }); // For debugging

  if (!currentPassword || !newPassword || !confirmPassword) {
    alert('Please fill in all fields');
    return;
  }

  if (newPassword !== confirmPassword) {
    alert('New passwords do not match');
    return;
  }

  try {
    // Verify current password first
    const userDoc = await db.collection('login')
      .where("id", "==", currentUser.id)
      .get();

    if (userDoc.empty || userDoc.docs[0].data().password !== currentPassword) {
      alert('Current password is incorrect');
      return;
    }

    // Update password
    await db.collection('login').doc(userDoc.docs[0].id).update({
      password: newPassword
    });

    alert('Password changed successfully');
    closeChangePasswordModal();
  } catch (error) {
    console.error('Error changing password:', error);
    alert('Error changing password');
  }
}

// Add to your existing window.onclick handler
window.onclick = function (event) {
  const multiDeleteModal = document.getElementById('multiDeleteModal');
  const changePasswordModal = document.getElementById('changePasswordModal');
  if (event.target == multiDeleteModal) {
    closeMultiDeleteModal();
  }
  if (event.target == changePasswordModal) {
    closeChangePasswordModal();
  }
}

async function deleteSelectedSadhakas() {
  const selected = Array.from(document.querySelectorAll('#sadhakaCheckboxList input:checked'))
    .map(cb => cb.value);

  if (selected.length === 0) {
    alert('Please select at least one sadhaka to delete');
    return;
  }

  if (confirm(`Are you sure you want to delete ${selected.length} sadhaka(s)?`)) {
    try {
      const batch = db.batch();
      selected.forEach(name => {
        const ref = db.collection('sadhakas').doc(name);
        batch.delete(ref);
      });

      await batch.commit();
      alert('Selected sadhakas deleted successfully');

      // Update the sadhaka names list
      sadhakaNames = sadhakaNames.filter(name => !selected.includes(name));
      populateSadhakaNameList();

      // Clear the form and close modal
      document.getElementById('sadhakaName').value = '';
      clearSadhakaDiv();
      closeMultiDeleteModal();
    } catch (error) {
      console.error('Error deleting sadhakas:', error);
      alert('Error deleting sadhakas');
    }
  }
}

// Close modal when clicking outside
window.onclick = function (event) {
  const modal = document.getElementById('multiDeleteModal');
  if (event.target == modal) {
    closeMultiDeleteModal();
  }
}

function sadhakaNameChanged(name) {
  // Clear suggestions (if they exist)
  var suggestionsDiv = document.getElementById('sadhakaNameSuggestions');
  if (suggestionsDiv) {
    suggestionsDiv.innerHTML = ''; // clear previous suggestions
    suggestionsDiv.style.display = 'none';
  }

  // Always clear the form BEFORE attempting to load new sadhaka data
  // This ensures a clean slate and avoids issues with elements from previous loads.
  clearSadhakaDiv();

  var matchingNames = sadhakaNames.filter(sadhakaName => sadhakaName.toLowerCase().startsWith(name.toLowerCase()));
  if (matchingNames.length > 0 && name.length > 0) {
    if (suggestionsDiv) suggestionsDiv.style.display = 'block';
    matchingNames.forEach(sadhakaName => {
      var suggestionDiv = document.createElement('div');
      suggestionDiv.textContent = sadhakaName;
      suggestionDiv.onclick = function () {
        sadhakaNameInput.value = sadhakaName;
        if (suggestionsDiv) {
          suggestionsDiv.innerHTML = '';
          suggestionsDiv.style.display = 'none';
        }
        loadSadhaka(sadhakaName);
      };
      if (suggestionsDiv) suggestionsDiv.appendChild(suggestionDiv);
    });
  }

  // If the entered name exactly matches an existing sadhaka, load it.
  // This is for when the user types the full name without selecting from suggestions.
  if (sadhakaNames.includes(name)) {
    loadSadhaka(name);
  }
}

function clearSadhakaDiv() {
  categories.forEach(category => {
    if (category.type === 'text') {
      const element = document.getElementById(category.elementId);
      if (element) {
        // Only clear if it's not a default text (e.g., prayer, diet, routine)
        if (![defaultPrayerText, defaultDietText, defaultRoutineText].includes(element.value)) {
          element.value = '';
        }
      }
    } else if (category.type === 'asanas') {
      const containerDiv = document.getElementById(category.elementId);
      if (containerDiv) {
        containerDiv.innerHTML = ''; // Clear all asana divs
      }
    }
  });
  // Explicitly set default texts for those sections
  document.getElementById('prayerText').value = defaultPrayerText;
  document.getElementById('dietAndAdditionalNotes').value = defaultDietText;
  document.getElementById('routineText').value = defaultRoutineText;
  document.getElementById('advisoryText').value = ''; // Advisory typically starts empty
  document.getElementById('jointsAndGlandsNotes').value = '';
  document.getElementById('cardioNotes').value = '';
  document.getElementById('nonCardioNotes').value = '';
}


function createAsanaDivWithCategory(asana, category) {
  const excludeIndividualNotes = ['Joints and Glands', 'Physical Asana'];
  const excludeRepetitions = ['Joints and Glands', 'Physical Asana'];

  var asanaDiv = document.createElement('div');
  asanaDiv.style.display = 'flex';
  asanaDiv.style.flexWrap = 'nowrap'; // Changed to 'nowrap'
  asanaDiv.style.alignItems = 'center';
  asanaDiv.style.justifyContent = 'space-between'; // Distribute space
  asanaDiv.style.marginBottom = '10px';
  asanaDiv.style.width = '100%'; // Ensure it takes full width of its parent

  var asanaNameSelect = createAsanaNameSelect(category);
  asanaDiv.appendChild(asanaNameSelect);

  // Initialize Select2 after appending to DOM for proper width calculation
  $(asanaNameSelect).select2({
    width: 'resolve', // Let Select2 calculate width based on container
    minimumResultsForSearch: 1
  });

  var infoButton = createInfoButton(asanaNameSelect);
  infoButton.style.flexShrink = '0'; // Prevent button from shrinking
  infoButton.style.marginLeft = '10px';
  infoButton.style.marginRight = '10px'; // Space from repetition input
  asanaDiv.appendChild(infoButton);

  // Add repetitions only for categories that don't have section notes
  if (!excludeRepetitions.includes(category)) {
    var repetitionsInput = createRepetitionsInput(asana);
    repetitionsInput.style.flex = '1'; // Give it a flexible width
    repetitionsInput.style.maxWidth = '80px'; // Limit max width
    repetitionsInput.style.marginRight = '10px';
    asanaDiv.appendChild(repetitionsInput);
  } else {
    // If repetitions are excluded, give the select more space
    $(asanaNameSelect).next('.select2-container').css('flex', '5'); // Adjust flex for Select2 container
  }

  // Only add special notes for non-excluded categories
  if (!excludeIndividualNotes.includes(category)) {
    var specialNotesTextarea = createSpecialNotesTextarea(asana);
    specialNotesTextarea.style.flex = '2'; // Give it a flexible width
    specialNotesTextarea.style.marginRight = '10px';
    asanaDiv.appendChild(specialNotesTextarea);
  }

  var deleteButton = createDeleteButton(asanaDiv);
  deleteButton.style.flexShrink = '0'; // Prevent button from shrinking
  deleteButton.style.marginLeft = 'auto'; // Push to the right
  asanaDiv.appendChild(deleteButton);

  return asanaDiv;
}

function createAsanaNameSelect(category) {
  var asanaNameSelect = document.createElement('select');
  // The styling for flex and margin will be handled by the CSS for .select2-container
  asanaNameSelect.classList.add('asanaNameSelect');

  // Filter asanas by category
  var filteredAsanas = asanas.filter(asana => asana[3] === category);

  // Populate the dropdown options
  filteredAsanas.forEach((asanaOption) => {
    var option = document.createElement('option');
    option.value = asanaOption[0];
    option.text = asanaOption[2] || asanaOption[0]; // Use displayName if available, otherwise use name
    asanaNameSelect.appendChild(option);
  });

  return asanaNameSelect;
}

function createInfoButton(asanaNameSelect) {
  var infoButton = document.createElement('button');
  infoButton.textContent = '?';
  infoButton.className = 'info-button';

  infoButton.addEventListener('click', function (event) {
    event.stopPropagation();

    var asanaName = asanaNameSelect.value;
    var asana = asanas.find(asana => asana[0] === asanaName);

    if (asana) {
      displayAsanaDescription(asana[1], infoButton);
    }
  });

  return infoButton;
}

function createRepetitionsInput(asana) {
  var repetitionsInput = document.createElement('input');
  repetitionsInput.id = 'repetitionsInput';
  repetitionsInput.value = asana && asana.repetitions ? asana.repetitions : '';
  repetitionsInput.placeholder = 'Repetitions';
  repetitionsInput.style.flex = '2';
  repetitionsInput.style.margin = '0 10px';
  return repetitionsInput;
}

function createSpecialNotesTextarea(asana) {
  var specialNotesTextarea = document.createElement('textarea');
  specialNotesTextarea.id = 'specialNotesTextarea';
  specialNotesTextarea.value = asana && asana.specialNotes ? asana.specialNotes : '';
  specialNotesTextarea.style.flex = '0.8';
  specialNotesTextarea.placeholder = 'Special notes';
  specialNotesTextarea.className = 'special-notes';
  specialNotesTextarea.style.margin = '0 10px';
  return specialNotesTextarea;
}

function createDeleteButton(asanaDiv) {
  var deleteButton = document.createElement('button');
  deleteButton.textContent = '-';
  deleteButton.className = 'delete-button';
  deleteButton.onclick = function () {
    asanaDiv.remove();
  }
  deleteButton.style.margin = '0 10px'; // Added margins to leave gaps

  return deleteButton;
}


function displaySadhaka(sadhaka) {
  // Load category notes
  document.getElementById('jointsAndGlandsNotes').value = sadhaka.jointsAndGlandsNotes || '';
  document.getElementById('cardioNotes').value = sadhaka.cardioNotes || '';
  document.getElementById('nonCardioNotes').value = sadhaka.nonCardioNotes || '';

  // Get the main container for sections (assuming body is the parent, adjust if different)
  const mainContainer = document.body;

  // Ensure all sections are present in the categories array
  // If a new category is added but an old sadhaka doesn't have it saved, this ensures it appears.
  const allCategoryIds = categories.map(cat => cat.id);
  let currentCategoryOrder = sadhaka.categoryOrder || allCategoryIds;

  // Filter out any IDs in saved order that no longer exist in `categories`
  currentCategoryOrder = currentCategoryOrder.filter(id => allCategoryIds.includes(id));
  // Add any new categories (not in saved order) to the end
  const newCategories = allCategoryIds.filter(id => !currentCategoryOrder.includes(id));
  currentCategoryOrder = currentCategoryOrder.concat(newCategories);

  // Create a map for quick lookup of category definitions by ID
  const categoryMap = new Map(categories.map(cat => [cat.id, cat]));

  // Create a document fragment to append sections efficiently
  const fragment = document.createDocumentFragment();

  // Iterate through the determined order and append actual section elements to the fragment
  currentCategoryOrder.forEach(sectionId => {
    const sectionElement = document.getElementById(sectionId);
    if (sectionElement) {
      fragment.appendChild(sectionElement);
    }
  });

  // Append the reordered fragment to the body (or your main content div)
  // This ensures the DOM elements are in the correct order for drag-and-drop
  mainContainer.append(fragment);

  // Now populate content based on the (potentially new) order
  categories.forEach(category => { // Iterate through original 'categories' for data population logic
    if (category.type === 'text') {
      const element = document.getElementById(category.elementId);
      if (element) {
        if (category.elementId === 'dietAndAdditionalNotes' && (!sadhaka[category.elementId] || sadhaka[category.elementId].trim() === '')) {
          element.value = defaultDietText;
        } else if (category.elementId === 'routineText' && (!sadhaka[category.elementId] || sadhaka[category.elementId].trim() === '')) {
          element.value = defaultRoutineText;
        } else {
          element.value = sadhaka[category.elementId] || '';
        }
      }
    } else if (category.type === 'asanas') {
      var containerDiv = document.getElementById(category.elementId);
      if (containerDiv) {
        containerDiv.innerHTML = ''; // Clear previous content before repopulating
        if (Array.isArray(sadhaka[category.elementId])) {
          sadhaka[category.elementId].forEach(asana => {
            var asanaDiv = createAsanaDivWithCategory(asana, category.category);
            containerDiv.appendChild(asanaDiv);
          });
        }
      }
    }
  });
  console.log("Sadhaka data displayed successfully.");

  // IMPORTANT: Re-setup drag and drop after reordering DOM elements
  setupDragAndDrop();
}

function displayAsanasForCategory(asanaList, containerDiv, category) {
  if (Array.isArray(asanaList)) {
    asanaList.forEach((asana) => {
      var asanaDiv = createAsanaDivWithCategory(asana, category);
      containerDiv.appendChild(asanaDiv);
    });
  } else {
    console.warn(`Asana list for category ${category} is not an array:`, asanaList);
  }
}

function createAsanaDiv() {
  var asanaDiv = document.createElement('div');
  asanaDiv.style.display = 'flex';
  asanaDiv.style.flexWrap = 'no-wrap';
  asanaDiv.style.alignItems = 'center'; // This will vertically align items
  asanaDiv.style.justifyContent = 'space-between';
  asanaDiv.style.marginBottom = '10px';

  return asanaDiv;
}

function addAsana(divId, category) {
  console.log("Adding asana. Category:", category, "Asanas:", asanas);
  if (!Array.isArray(asanas) || asanas.length === 0) {
    console.error("Asanas not loaded properly. Attempting to reload...");
    loadAsanas().then((fetchedAsanas) => {
      asanas = fetchedAsanas;
      addAsanaToDiv(divId, category);
    }).catch((error) => {
      console.error("Error reloading asanas:", error);
    });
  } else {
    addAsanaToDiv(divId, category);
  }
}

function addAsanaToDiv(divId, category) {
  var categoryDiv = document.getElementById(divId);
  var asanaDiv = createAsanaDiv(); // Use existing createAsanaDiv
  var asanaNameSelect = createAsanaNameSelect(category);
  asanaDiv.appendChild(asanaNameSelect);

  $(asanaNameSelect).select2({
    width: 'resolve', // Let Select2 calculate width based on container
    minimumResultsForSearch: 1
  });

  var infoButton = createInfoButton(asanaNameSelect);
  infoButton.style.flexShrink = '0';
  infoButton.style.marginLeft = '10px';
  infoButton.style.marginRight = '10px';
  asanaDiv.appendChild(infoButton);

  // Add repetitions only for categories that don't have section notes
  if (category !== 'Joints and Glands' && category !== 'Physical Asana') {
    var repetitionsInput = createRepetitionsInput();
    repetitionsInput.style.flex = '1';
    repetitionsInput.style.maxWidth = '80px';
    repetitionsInput.style.marginRight = '10px';
    asanaDiv.appendChild(repetitionsInput);
  } else {
    $(asanaNameSelect).next('.select2-container').css('flex', '5');
  }

  // Only add special notes for non-excluded categories
  if (category !== 'Joints and Glands' && category !== 'Physical Asana') {
    var specialNotesTextarea = createSpecialNotesTextarea();
    specialNotesTextarea.style.flex = '2';
    specialNotesTextarea.style.marginRight = '10px';
    asanaDiv.appendChild(specialNotesTextarea);
  }

  var deleteButton = createDeleteButton(asanaDiv);
  deleteButton.style.flexShrink = '0';
  deleteButton.style.marginLeft = 'auto';
  asanaDiv.appendChild(deleteButton);

  categoryDiv.appendChild(asanaDiv);
}


function validateAsanaName(name, asanaNameSelect) {
  var matchingAsana = asanas.find(asana => asana[0].toLowerCase() === name.toLowerCase());
  if (matchingAsana) {
    asanaNameSelect.style.border = '1px solid green';
  } else {
    asanaNameSelect.style.border = '1px solid red';
  }
}

function displayAsanaDescription(description, infoButton) {
  var asanaDescriptionDiv = document.getElementById('asanaDescription');
  asanaDescriptionDiv.textContent = description;
  asanaDescriptionDiv.style.display = 'block';

  // Calculate the position of the infoButton
  var infoButtonRect = infoButton.getBoundingClientRect();
  var infoButtonTop = infoButtonRect.top + window.pageYOffset;
  var infoButtonLeft = infoButtonRect.left + window.pageXOffset;

  // Position the description next to the infoButton
  asanaDescriptionDiv.style.top = infoButtonTop + 'px';
  asanaDescriptionDiv.style.left = (infoButtonLeft + infoButton.offsetWidth) + 'px';

  // Add click event handler to document
  document.addEventListener('click', function hideDescription(e) {
    if (!asanaDescriptionDiv.contains(e.target) && !infoButton.contains(e.target)) {
      asanaDescriptionDiv.style.display = 'none';
      document.removeEventListener('click', hideDescription);
    }
  });
}

function hideAsanaDescription() {
  var asanaDescriptionDiv = document.getElementById('asanaDescription');
  asanaDescriptionDiv.style.display = 'none';
}

function loadSadhaka(name) {
  console.log("Loading sadhaka:", name);
  if (!Array.isArray(asanas) || asanas.length === 0) {
    console.log("Asanas not loaded, loading them first...");
    loadAsanas()
      .then((fetchedAsanas) => {
        asanas = fetchedAsanas;
        fetchAndDisplaySadhaka(name);
      })
      .catch((error) => {
        console.error("Error loading asanas:", error);
      });
  } else {
    fetchAndDisplaySadhaka(name);
  }

  // Ensure save buttons are visible when a sadhaka is loaded
  document.querySelector('button[onclick="saveSadhakaWithCategory()"]').style.display = 'inline-block';
  document.querySelector('button[onclick="saveSadhakaReportAsPdf()"]').style.display = 'inline-block';
}

function fetchAndDisplaySadhaka(name) {
  db.collection('sadhakas').doc(name).get()
    .then((doc) => {
      if (doc.exists) {
        console.log("Sadhaka data found:", doc.data());
        displaySadhaka(doc.data());
      } else {
        console.log("No sadhaka found with name:", name);
        var newSadhaka = {
          name: name,
          prayerText: '',
          dietAndAdditionalNotes: ''
        };
        categories.forEach(category => {
          if (category.type === 'asanas') {
            newSadhaka[category.id] = [];
          }
        });
        displaySadhaka(newSadhaka);
      }
    })
    .catch((error) => {
      console.error("Error getting document:", error);
    });
}


async function saveSadhakaWithCategory() {
  var sadhakaName = sadhakaNameInput.value;
  if (!sadhakaName) {
    alert('Please enter a Sadhaka name to save.');
    return;
  }

  var sadhaka = {
    name: sadhakaName,
    jointsAndGlandsNotes: document.getElementById('jointsAndGlandsNotes').value,
    cardioNotes: document.getElementById('cardioNotes').value,
    nonCardioNotes: document.getElementById('nonCardioNotes').value
  };

  categories.forEach(category => {
    if (category.type === 'text') {
      sadhaka[category.elementId] = document.getElementById(category.elementId).value;
    } else if (category.type === 'asanas') {
      sadhaka[category.elementId] = getAsanasFromDiv(document.getElementById(category.elementId));
    }
  });

  // Save the current order of sections
  const sectionElements = document.querySelectorAll('.section');
  sadhaka.categoryOrder = Array.from(sectionElements).map(section => section.id);

  saveSadhakaToDB(sadhaka).then(() => {
    alert('Saved successfully!');
    // Update sadhakaNames if it's a new sadhaka
    if (!sadhakaNames.includes(sadhakaName)) {
      sadhakaNames.push(sadhakaName);
      populateSadhakaNameList();
    }
  }).catch((error) => {
    console.log("Error saving sadhaka:", error);
    alert('Error saving Sadhaka. Please check the console for details.');
  });
}

let currentUser = null;


function login() {
  const usernameInput = document.getElementById('username').value;
  const passwordInput = document.getElementById('password').value;

  const db = firebase.firestore();
  db.collection("login")
    .where("id", "==", usernameInput)
    .get()
    .then((querySnapshot) => {
      if (querySnapshot.empty) {
        alert("Invalid username or password. Please try again.");
        return;
      }

      const loginData = querySnapshot.docs[0].data();
      if (passwordInput === loginData.password) {
        currentUser = loginData; // Store the current user info
        alert("Login successful!");

        // Hide both login container and overlay properly
        const loginContainer = document.querySelector('.login-container');
        const overlay = document.querySelector('#overlay');

        // Hide both elements completely
        loginContainer.style.display = 'none';
        loginContainer.style.visibility = 'hidden';
        overlay.style.display = 'none';
        overlay.style.visibility = 'hidden';

        // Show logged in user info
        const loginStatus = document.getElementById('loginStatus');
        const loggedInUser = document.getElementById('loggedInUser');
        loggedInUser.textContent = loginData.id;
        loginStatus.style.display = 'block';

        // Show/hide manage users button based on admin status
        const manageUsersBtn = document.querySelector('[onclick="showUserManagement()"]');
        manageUsersBtn.style.display = loginData.isAdmin ? 'block' : 'none';

        // Show save buttons after successful login
        document.querySelector('button[onclick="saveSadhakaWithCategory()"]').style.display = 'inline-block';
        document.querySelector('button[onclick="saveSadhakaReportAsPdf()"]').style.display = 'inline-block';

        initialize();
      } else {
        alert("Invalid username or password. Please try again.");
      }
    })
    .catch((error) => {
      console.log("Error checking login credentials:", error);
      alert("An error occurred during login. Please try again.");
    });
}


function showMultiAsanaModal(category, asanaCategory) {
  console.log("Showing multi asana modal. Category:", category, "Asana Category:", asanaCategory);
  var modal = document.getElementById('multiAsanaModal');
  modal.style.display = "block";
  modal.setAttribute('data-category', category);
  modal.setAttribute('data-asana-category', asanaCategory);
  populateAsanaCheckboxList(asanaCategory);
}


function closeMultiAsanaModal() {
  var modal = document.getElementById('multiAsanaModal');
  modal.style.display = "none";
}

// Modified populateAsanaCheckboxList function to use displayName
function populateAsanaCheckboxList(category) {
  console.log("Populating asana checkbox list. Category:", category, "Asanas:", asanas);
  var tableBody = document.getElementById('asanaCheckboxTableBody');
  tableBody.innerHTML = '';

  var filteredAsanas = asanas.filter(asana => asana[3] === category);
  console.log("Filtered asanas for checkboxes:", filteredAsanas);

  filteredAsanas.forEach(asana => {
    var row = tableBody.insertRow();

    var checkboxCell = row.insertCell(0);
    var checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.value = asana[0];
    checkbox.id = "asana_" + asana[0];
    checkboxCell.appendChild(checkbox);

    var nameCell = row.insertCell(1);
    var nameLabel = document.createElement('label');
    nameLabel.htmlFor = "asana_" + asana[0];
    nameLabel.textContent = asana[2] || asana[0]; // Use displayName if available, otherwise use name
    nameCell.appendChild(nameLabel);
  });
}

// Modified addMultipleAsanas function to use the correct category
function addMultipleAsanas() {
  var modal = document.getElementById('multiAsanaModal');
  var category = modal.getAttribute('data-category');
  var asanaCategory = modal.getAttribute('data-asana-category');
  var rows = document.querySelectorAll('#asanaCheckboxTableBody tr');

  rows.forEach(row => {
    var checkbox = row.querySelector('input[type="checkbox"]');
    if (checkbox.checked) {
      var asanaName = checkbox.value;
      var asana = {
        asanaName: asanaName,
        repetitions: '',
        specialNotes: ''
      };
      addAsanaToCategory(asana, category, asanaCategory);
    }
  });

  closeMultiAsanaModal();
}


function addAsanaToCategory(asana, category, asanaCategory) {
  var categoryDiv = document.getElementById(category);
  var asanaDiv = createAsanaDivWithCategory(asana, asanaCategory);
  categoryDiv.appendChild(asanaDiv);
}

function filterAsanas() {
  var searchValue = document.getElementById('asanaSearch').value.toLowerCase();
  var rows = document.querySelectorAll('#asanaCheckboxTableBody tr');

  rows.forEach(row => {
    var asanaName = row.querySelector('label').textContent.toLowerCase();
    var displayName = row.querySelector('.display-name-input').value.toLowerCase();
    if (asanaName.includes(searchValue) || displayName.includes(searchValue)) {
      row.style.display = "";
    } else {
      row.style.display = "none";
    }
  });
}

// When the user clicks outside of the modal, close it
window.onclick = function (event) {
  var modal = document.getElementById('multiAsanaModal');
  if (event.target == modal) {
    closeMultiAsanaModal();
  }
}

async function initializeDefaultUsers() {
  const defaultUsers = [
    { id: 'radhikama', password: 'samaya', isAdmin: true }
  ];

  for (const user of defaultUsers) {
    const userDoc = await db.collection('login').doc(user.id).get();
    if (!userDoc.exists) {
      await db.collection('login').doc(user.id).set(user);
    }
  }
}

async function loadUsers() {
  const usersTableBody = document.getElementById('usersTableBody');
  usersTableBody.innerHTML = '';

  try {
    const snapshot = await db.collection('login').get();
    snapshot.forEach((doc) => {
      const userData = doc.data();
      const row = document.createElement('tr');
      row.style.borderBottom = '1px solid #ddd';

      const nameCell = document.createElement('td');
      nameCell.textContent = userData.id;
      nameCell.style.padding = '12px';
      nameCell.style.border = '1px solid #ddd';

      const adminCell = document.createElement('td');
      adminCell.textContent = userData.isAdmin ? 'Admin' : 'User';
      adminCell.style.padding = '12px';
      adminCell.style.border = '1px solid #ddd';

      const actionCell = document.createElement('td');
      actionCell.style.padding = '12px';
      actionCell.style.border = '1px solid #ddd';

      if (userData.id !== 'radhikama' && userData.id !== 'samaya') {
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.style.padding = '6px 12px';
        deleteButton.style.backgroundColor = '#ff4444';
        deleteButton.style.color = 'white';
        deleteButton.style.border = 'none';
        deleteButton.style.borderRadius = '4px';
        deleteButton.style.cursor = 'pointer';
        deleteButton.onmouseover = function () {
          this.style.backgroundColor = '#cc0000';
        };
        deleteButton.onmouseout = function () {
          this.style.backgroundColor = '#ff4444';
        };
        deleteButton.onclick = () => deleteUser(userData.id);
        actionCell.appendChild(deleteButton);
      }

      row.appendChild(nameCell);
      row.appendChild(adminCell);
      row.appendChild(actionCell);
      usersTableBody.appendChild(row);
    });
  } catch (error) {
    showUserMessage('Error loading users: ' + error.message, true);
  }
}

async function addUser() {
  const username = document.getElementById('newUsername').value;
  const password = document.getElementById('newPassword').value;
  const isAdmin = document.getElementById('isAdmin').checked;

  if (!username || !password) {
    showUserMessage('Please enter both username and password', true);
    return;
  }

  try {
    await db.collection('login').doc(username).set({
      id: username,
      password: password,
      isAdmin: isAdmin
    });

    document.getElementById('newUsername').value = '';
    document.getElementById('newPassword').value = '';
    document.getElementById('isAdmin').checked = false;
    showUserMessage('User added successfully');
    loadUsers();
  } catch (error) {
    showUserMessage('Error adding user: ' + error.message, true);
  }
}
// Delete user
async function deleteUser(userId) {
  if (userId === 'radhikama' || userId === 'samaya') {
    showUserMessage('Cannot delete default users', true);
    return;
  }

  try {
    await db.collection('login').doc(userId).delete();
    showUserMessage('User deleted successfully');
    loadUsers();
  } catch (error) {
    showUserMessage('Error deleting user: ' + error.message, true);
  }
}

function showUserMessage(message, isError = false) {
  const messageDiv = document.getElementById('userMessage');
  messageDiv.textContent = message;
  messageDiv.style.padding = '10px';
  messageDiv.style.marginTop = '10px';
  messageDiv.style.marginBottom = '10px';
  messageDiv.style.borderRadius = '4px';
  messageDiv.style.backgroundColor = isError ? '#ffe6e6' : '#e6ffe6';
  messageDiv.style.color = isError ? '#cc0000' : '#006600';
  messageDiv.style.border = `1px solid ${isError ? '#ffcccc' : '#ccffcc'}`;

  setTimeout(() => {
    messageDiv.textContent = '';
    messageDiv.style.padding = '0';
    messageDiv.style.border = 'none';
    messageDiv.style.backgroundColor = 'transparent';
  }, 3000);
}

function showUserManagement() {
  if (!currentUser?.isAdmin) {
    alert("You don't have permission to access user management.");
    return;
  }

  const modal = document.getElementById('userManagementModal');
  modal.style.display = 'block';
  loadUsers();
}


function setupDragAndDrop() {
  const sections = document.querySelectorAll('.section');
  let draggedItem = null; // This variable will be used by the named functions

  // Define named event handler functions
  const handleDragStart = (e) => {
    draggedItem = e.currentTarget.closest('.section'); // Get the parent section
    setTimeout(() => {
      draggedItem.classList.add('dragging');
    }, 0);
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', draggedItem.id);
  };

  const handleDragEnd = () => {
    if (draggedItem) {
      draggedItem.classList.remove('dragging');
      draggedItem = null;
    }
  };

  const handleDragOver = (e) => {
    e.preventDefault(); // Necessary to allow a drop
    const targetSection = e.currentTarget; // The section currently being dragged over

    if (draggedItem && draggedItem !== targetSection) {
      const rect = targetSection.getBoundingClientRect();
      const isAfter = (e.clientY - rect.top) / (rect.height) > 0.5;

      const parent = targetSection.parentNode;
      if (isAfter && targetSection.nextSibling) {
        // If dragging over bottom half and there's a next sibling, insert after
        parent.insertBefore(draggedItem, targetSection.nextSibling);
      } else if (!isAfter) {
        // If dragging over top half, insert before
        parent.insertBefore(draggedItem, targetSection);
      }
    }
  };

  const handleDrop = (e) => {
    e.preventDefault();
    // The actual reordering happens in dragover, so drop just prevents default browser behavior
  };

  sections.forEach(section => {
    // Find the h2 element within the section to use as the drag handle
    const h2Handle = section.querySelector('h2');

    // Remove existing listeners to prevent duplicates before re-attaching
    // This is crucial if setupDragAndDrop is called multiple times (e.g., after loading sadhaka)
    if (h2Handle) {
      h2Handle.removeEventListener('dragstart', handleDragStart);
      h2Handle.removeEventListener('dragend', handleDragEnd);
    }
    section.removeEventListener('dragover', handleDragOver);
    section.removeEventListener('drop', handleDrop);


    // Attach new listeners
    if (h2Handle) {
      h2Handle.setAttribute('draggable', 'true'); // Make the h2 draggable
      h2Handle.addEventListener('dragstart', handleDragStart);
      h2Handle.addEventListener('dragend', handleDragEnd);
    }
    section.addEventListener('dragover', handleDragOver);
    section.addEventListener('drop', handleDrop);
  });
}

function closeUserManagementModal() {
  const modal = document.getElementById('userManagementModal');
  modal.style.display = 'none';
}

// Initialize default users when the application starts
document.addEventListener('DOMContentLoaded', () => {
  initializeDefaultUsers();
});

// Close modal when clicking outside
window.onclick = function (event) {
  const modal = document.getElementById('userManagementModal');
  if (event.target == modal) {
    closeUserManagementModal();
  }
}

window.onload = initialize;
